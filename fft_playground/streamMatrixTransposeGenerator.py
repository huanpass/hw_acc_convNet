"""
This file is to generate p*p crossbar given k and M
M is the matrix size, k is p/M, # of lines processed in one cycle
"""

from generateVerilogUtil import *
import math


def getInputIndexMatrixTranspose(outputIndex, k, M):
    assert M % k == 0, "k must be a divisor of M."
    groupIndex = outputIndex // M  # from [0, k)
    groupOffset = outputIndex % M  # from [0, M)
    subGroupIndex = groupOffset // k  # from [0, M/k)
    subGroupOffset = groupOffset % k  # from [0, k)
    j = groupIndex + 1 + subGroupIndex * k
    i = subGroupOffset + 1
    return (i - 1) * M + j - 1, i, j


def getInputIndexShiftCrossbar(outputIndex, k, M, shiftNum):
    assert M % k == 0, "k must be a divisor of M."
    assert shiftNum % k == 0, "k must be a divisor of shiftNum"
    return (outputIndex - shiftNum) % (k * M)

def getShiftCrossbarPair(k, M, shiftNum):
    result = []
    for i in range(k * M):
        outputStr = "out" + str(i)
        inputStr = "in" + str(getInputIndexShiftCrossbar(i, k, M, shiftNum))
        result.append((inputStr, outputStr))
    return result


def generateCrossbarVerilog(k, M, inputWidth, pipeline, fileName):
    f = open(fileName, "w")
    # generate the top comment
    f.write(generateVerilogNewLine(0, "/*"))
    f.write(generateVerilogNewLine(1, "* This file is automatically generated by Chi Zhang"))
    f.write(generateVerilogNewLine(1, "* k = " + str(k) + ", M = " + str(M)))
    f.write(generateVerilogNewLine(1, "*/"))
    crossbarSize = k * M
    crossbar = VerilogModule("crossbar" + str(crossbarSize) + "x" + str(crossbarSize))
    crossbar.addIO(ModuleIO(1, "clk", "input"))
    crossbar.addIO(ModuleIO(1, "clk_en", "input"))
    crossbar.addParam(ModuleParam("DATA_WIDTH", inputWidth))
    inputWidth = "DATA_WIDTH"
    for i in range(k  * M):
        crossbar.addIO(ModuleIO(inputWidth, "in" + str(i), "input"))

    if pipeline:
        for i in range(k * M):
            crossbar.addIO(ModuleIO(inputWidth, "out" + str(i), "output reg"))

        f.write(crossbar.__str__())
        f.write("\n")

        f.write(generateVerilogNewLine(2, "always@(posedge clk) begin"))
        f.write(generateVerilogNewLine(4, "if (clk_en) begin"))
        for outIO in crossbar.io:
            if outIO.getType() == "output reg":
                if len(outIO.getName()) == 4:
                    outIndex = outIO.getName()[-1:]
                else:
                    outIndex = outIO.getName()[-2:]
                inputIndex, _, _ = getInputIndexMatrixTranspose(int(outIndex), k, M)
                f.write(generateVerilogNewLine(6, outIO.getName() + " <= " + "in" + str(inputIndex) + ";"))
        f.write(generateVerilogNewLine(4, "end"))
        f.write(generateVerilogNewLine(2, "end"))
        f.write("\n")
        f.write(generateVerilogNewLine(0, "endmodule"))
        f.close()
    else:
        raise NotImplementedError("Not pipeline design is not implemented yet.")


def generateShiftCrossbarVerilog(k, M, defaultInputWidth, fileName):
    f = open(fileName, "w")
    # generate the top comment
    f.write(generateVerilogNewLine(0, "/*"))
    f.write(generateVerilogNewLine(1, "* This file is automatically generated by Chi Zhang"))
    f.write(generateVerilogNewLine(1, "* k = " + str(k) + ", M = " + str(M)))
    f.write(generateVerilogNewLine(1, "*/"))
    crossbarSize = k * M
    # generate module io
    crossbar = VerilogModule("crossbarShift" + str(crossbarSize) + "x" + str(crossbarSize))
    crossbar.addIO(ModuleIO(1, "clk", "input"))
    crossbar.addIO(ModuleIO(1, "clk_en", "input"))
    crossbar.addIO(ModuleIO(int(math.log(M / k, 2)), "timestamp", "input"))
    crossbar.addParam(ModuleParam("DATA_WIDTH", defaultInputWidth))
    inputWidth = "DATA_WIDTH"
    for i in range(k  * M):
        crossbar.addIO(ModuleIO(inputWidth, "in" + str(i), "input"))
    for i in range(k * M):
            crossbar.addIO(ModuleIO(inputWidth, "out" + str(i), "output reg"))

    f.write(crossbar.__str__())
    f.write("\n")

    # generate the

if __name__ == "__main__":
    k, M = 4, 8
    crossbarSize = k * M
    if False:
        fileName = generatedVerilogFolder + "crossbar" + str(crossbarSize) + "x" + str(crossbarSize) + ".v"
        generateCrossbarVerilog(k, M, inputWidth=32, pipeline=True, fileName=fileName)
    if True:
        fileName = generatedVerilogFolder + "crossbarShift" + str(crossbarSize) + "x" + str(crossbarSize) + ".v"
        generateShiftCrossbarVerilog(k, M, defaultInputWidth=32, fileName=fileName)
