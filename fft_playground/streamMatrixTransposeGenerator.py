"""
This file is to generate p*p crossbar given k and M
M is the matrix size, k is p/M, # of lines processed in one cycle
"""

from generateVerilogUtil import *
import math


def getInputIndexMatrixTranspose(outputIndex, k, M):
    assert M % k == 0, "k must be a divisor of M."
    groupIndex = outputIndex // M  # from [0, k)
    groupOffset = outputIndex % M  # from [0, M)
    subGroupIndex = groupOffset // k  # from [0, M/k)
    subGroupOffset = groupOffset % k  # from [0, k)
    j = groupIndex + 1 + subGroupIndex * k
    i = subGroupOffset + 1
    return (i - 1) * M + j - 1, i, j


def getInputIndexShiftCrossbar(outputIndex, k, M, shiftNum):
    assert M % k == 0, "k must be a divisor of M."
    assert shiftNum % k == 0, "k must be a divisor of shiftNum"
    return (outputIndex - shiftNum) % (k * M)


def getShiftCrossbarPair(k, M, shiftNum):
    result = []
    for i in range(k * M):
        outputStr = "out" + str(i)
        inputStr = "in" + str(getInputIndexShiftCrossbar(i, k, M, shiftNum))
        result.append((inputStr, outputStr))
    return result


def generateCrossbarVerilog(k, M, inputWidth, fileName):
    f = open(fileName, "w")
    # generate the top comment
    f.write(generateVerilogNewLine(0, "/* " + fileName))
    f.write(generateVerilogNewLine(1, "* This file is automatically generated by Chi Zhang"))
    f.write(generateVerilogNewLine(1, "* k = " + str(k) + ", M = " + str(M)))
    f.write(generateVerilogNewLine(1, "*/"))
    crossbarSize = k * M
    crossbar = VerilogModule("crossbar" + str(crossbarSize) + "x" + str(crossbarSize))
    crossbar.addIO(ModuleIO(1, "clk", "input"))
    crossbar.addIO(ModuleIO(1, "clk_en", "input"))
    crossbar.addIO(ModuleIO(1, "reset", "input"))
    crossbar.addIO(ModuleIO(1, "start", "input"))
    crossbar.addParam(ModuleParam("DATA_WIDTH", inputWidth))
    inputWidth = "DATA_WIDTH"
    for i in range(k * M):
        crossbar.addIO(ModuleIO(inputWidth, "in" + str(i), "input"))

    startNextStageIO = ModuleIO(1, "start_next_stage", "output reg")
    crossbar.addIO(startNextStageIO)

    for i in range(k * M):
        crossbar.addIO(ModuleIO(inputWidth, "out" + str(i), "output reg"))

    f.write(crossbar.__str__())
    f.write("\n")

    # generate control block
    f.write(generateVerilogNewLine(2, "always@(posedge clk) begin"))
    f.write(generateVerilogNewLine(4, "if (reset) begin"))
    f.write(generateVerilogNewLine(6, generateAssignment(startNextStageIO, 0, "non-blocking")))
    f.write(generateVerilogNewLine(4, "end else if (clk_en & start) begin"))
    f.write(generateVerilogNewLine(6, generateAssignment(startNextStageIO, "start", "non-blocking")))
    f.write(generateVerilogNewLine(4, "end"))
    f.write(generateVerilogNewLine(2, "end"))
    f.write("\n")

    # generate always block
    f.write(generateVerilogNewLine(2, "always@(posedge clk) begin"))
    f.write(generateVerilogNewLine(4, "if (clk_en & start) begin"))
    for outIndex in range(k * M):
        inputIndex, _, _ = getInputIndexMatrixTranspose(int(outIndex), k, M)
        f.write(generateVerilogNewLine(6, "out" + str(outIndex) + " <= " + "in" + str(inputIndex) + ";"))
    f.write(generateVerilogNewLine(4, "end"))
    f.write(generateVerilogNewLine(2, "end"))
    f.write("\n")
    f.write(generateVerilogNewLine(0, "endmodule"))
    f.close()

def generateShiftCrossbarVerilog(k, M, defaultInputWidth, fileName, direction="down"):
    f = open(fileName, "w")
    # generate the top comment
    f.write(generateVerilogNewLine(0, "/* " + fileName))
    f.write(generateVerilogNewLine(1, "* This file is automatically generated by Chi Zhang"))
    f.write(generateVerilogNewLine(1, "* k = " + str(k) + ", M = " + str(M)))
    f.write(generateVerilogNewLine(1, "*/"))
    crossbarSize = k * M
    timestamp = M / k
    timestampLength = int(math.log(timestamp, 2))
    # generate module io
    crossbarShift = VerilogModule("crossbarShift" + str(crossbarSize) + "x" + str(crossbarSize))
    crossbarShift.addIO(ModuleIO(1, "clk", "input"))
    crossbarShift.addIO(ModuleIO(1, "clk_en", "input"))
    crossbarShift.addIO(ModuleIO(1, "start", "input"))
    crossbarShift.addIO(ModuleIO(1, "reset", "input"))
    crossbarShift.addParam(ModuleParam("DATA_WIDTH", defaultInputWidth))
    inputWidth = "DATA_WIDTH"
    for i in range(k * M):
        crossbarShift.addIO(ModuleIO(inputWidth, "in" + str(i), "input"))
    startNextStageModule = ModuleIO(1, "start_next_stage", "output reg")
    crossbarShift.addIO(startNextStageModule)
    for i in range(k * M):
        crossbarShift.addIO(ModuleIO(inputWidth, "out" + str(i), "output reg"))

    f.write(crossbarShift.__str__())
    f.write("\n")

    # generate control block
    t = ModuleReg(timestampLength, "timestamp")
    f.write(generateVerilogNewLine(2, t.__str__()))
    f.write("\n")
    f.write(generateVerilogNewLine(2, "always@(posedge clk) begin"))
    f.write(generateVerilogNewLine(4, "if (reset) begin"))
    f.write(generateVerilogNewLine(6, generateAssignment(startNextStageModule, 0, "non-blocking")))
    f.write(generateVerilogNewLine(6, generateAssignment(t, 0, "non-blocking")))
    f.write(generateVerilogNewLine(4, "end else if (clk_en & start) begin"))
    f.write(generateVerilogNewLine(6, generateAssignment(startNextStageModule, "start", "non-blocking")))
    f.write(generateVerilogNewLine(6, generateAssignment(t, "timestamp + 1", "non-blocking")))
    f.write(generateVerilogNewLine(4, "end"))
    f.write(generateVerilogNewLine(2, "end"))
    f.write("\n")

    # generate the always block
    f.write(generateVerilogNewLine(2, "always@(posedge clk) begin"))
    f.write(generateVerilogNewLine(4, "if (clk_en & start) begin"))
    f.write(generateVerilogNewLine(6, "case (timestamp)"))
    for i in range(timestamp):
        f.write(generateVerilogNewLine(8, numToVerilogBit(i, timestampLength) + ": begin"))
        if direction == "down":
            shiftNum = i * k
        elif direction == "up":
            shiftNum = - i * k
        else:
            raise NotImplementedError("Unknown direction")
        inOutPair = getShiftCrossbarPair(k, M, shiftNum)
        for inPort, outPort in inOutPair:
            f.write(generateVerilogNewLine(10, outPort + " <= " + inPort + ";"))
        f.write(generateVerilogNewLine(8, "end"))
    f.write(generateVerilogNewLine(6, "endcase"))
    f.write(generateVerilogNewLine(4, "end"))
    f.write(generateVerilogNewLine(2, "end"))
    f.write("\n")
    f.write(generateVerilogNewLine(0, "endmodule"))
    f.close()


"""
helper function to generate a single_port_ram for memArray
"""


def genSinglePortRam(k, M, index, baseIndent):
    result = ""
    result += generateVerilogNewLine(baseIndent, "single_port_ram # (")
    result += generateVerilogNewLine(baseIndent + 2, "")


def genMemArrayVerilog(k, M, defaultInputWidth, fileName):
    f = open(fileName, "w")
    # generate the top comment
    f.write(generateVerilogNewLine(0, "/* " + fileName))
    f.write(generateVerilogNewLine(1, "* This file is automatically generated by Chi Zhang"))
    f.write(generateVerilogNewLine(1, "* k = " + str(k) + ", M = " + str(M)))
    f.write(generateVerilogNewLine(1, "*/"))
    # generate module io
    memArray = VerilogModule("memArray" + str(M / k) + "x" + str(M * k))
    memArray.addIO(ModuleIO(1, "clk", "input"))
    memArray.addIO(ModuleIO(1, "we", "input"))
    memArray.addParam(ModuleParam("DATA_WIDTH", defaultInputWidth))
    inputWidth = "DATA_WIDTH"
    for i in range(k * M):
        memArray.addIO(ModuleIO(inputWidth, "in" + str(i), "input"))
    addressWidth = int(math.log(M / k, 2))
    for i in range(M):
        startIndex = i * k
        endIndex = startIndex + k - 1
        memArray.addIO(ModuleIO(addressWidth, "addr" + str(startIndex) + "_" + str(endIndex), "input"))
    for i in range(k * M):
        memArray.addIO(ModuleIO(inputWidth, "out" + str(i), "output"))

    f.write(memArray.__str__())
    f.write("\n")

    # generate the mem instantiation
    for i in range(M * k):
        mem = InstantiateModule("single_port_ram", "mem" + str(i), 2)
        mem.addParam(ModuleParam("DATA_WIDTH", "DATA_WIDTH"))
        mem.addParam(ModuleParam("ADDR_WIDTH", str(addressWidth)))
        mem.addIO(ModuleIO(None, "data", "input", "in" + str(i)))
        startIndex = int(i // k) * k
        endIndex = startIndex + k - 1
        mem.addIO(ModuleIO(None, "addr", "input", "addr" + str(startIndex) + "_" + str(endIndex)))
        mem.addIO(ModuleIO(None, "we", "input", "we"))
        mem.addIO(ModuleIO(None, "clk", "input", "clk"))
        mem.addIO(ModuleIO(None, "q", "out", "out" + str(i)))
        f.write(mem.__str__())
        f.write("\n")

    f.write(generateVerilogNewLine(0, "endmodule"))
    f.close()


if __name__ == "__main__":
    k, M = 4, 8
    crossbarSize = k * M
    generateCrossbar = True
    generateCrossbarShiftDown = False
    generateCrossbarShiftUp = False
    generateMemArray = False

    if generateCrossbar:
        fileName = generatedVerilogFolder + "crossbar" + str(crossbarSize) + "x" + str(crossbarSize) + ".v"
        generateCrossbarVerilog(k, M, inputWidth=32, fileName=fileName)

    if generateCrossbarShiftDown:
        fileName = generatedVerilogFolder + "crossbarShiftDown" + str(crossbarSize) + "x" + str(crossbarSize) + ".v"
        generateShiftCrossbarVerilog(k, M, defaultInputWidth=32, fileName=fileName, direction="down")

    if generateCrossbarShiftUp:
        fileName = generatedVerilogFolder + "crossbarShiftUp" + str(crossbarSize) + "x" + str(crossbarSize) + ".v"
        generateShiftCrossbarVerilog(k, M, defaultInputWidth=32, fileName=fileName, direction="up")

    if generateMemArray:
        fileName = generatedVerilogFolder + "memArrayFinal" + str(M / k) + "x" + str(M * k) + ".v"
        genMemArrayVerilog(k, M, defaultInputWidth=32, fileName=fileName)
